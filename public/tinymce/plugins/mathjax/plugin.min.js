tinymce.PluginManager.add("mathjax", function (editor) {
  // Inject CSS vào editor
  editor.on("init", function () {
    const style = document.createElement("style");
    style.textContent = `
      /* MathJax preview styling */
      .mathjax-preview {
        background: #f9fafb;
        padding: 16px;
        border-radius: 8px;
        border: 1px solid #e5e7eb;
        margin-top: 8px;
        text-align: center;
        min-height: 40px;
        font-size: 1.5rem;
        color: #222;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .mathjax-preview .mjx-chtml {
        font-family: 'Latin Modern Math', 'STIX Math', 'Cambria Math', 'Times New Roman', serif !important;
      }

      span.math-tex {
        font-family: 'Latin Modern Math', 'STIX Math', 'Cambria Math', 'Times New Roman', serif !important;
      }

      /* Block math styling */
      p>.math-tex {
        display: block !important;
        text-align: left !important;
        margin-left: 0 !important;
        margin-right: auto !important;
      }

      p>.math-tex .mjx-chtml {
        margin: 0 !important;
        text-align: left !important;
        display: block !important;
      }
    `;
    editor.getDoc().head.appendChild(style);
  });

  // --- MathJax Render Helpers ---
  function removeMathJaxOutput(el) {
    // Reset style của node math-tex
    el.removeAttribute("style");

    // Reset style của parent paragraph nếu có
    const parentP = el.closest("p");
    if (parentP) {
      parentP.removeAttribute("style");
    }

    // Xóa tất cả output cũ của MathJax trong node này
    el.querySelectorAll(".mjx-chtml, .mjx-math").forEach((n) => {
      n.remove();
      // Reset style của các node con
      n.removeAttribute("style");
    });
  }

  // --- Detect Math Mode ---
  function detectMathMode(latex) {
    const trimmed = latex.trim();
    if (
      trimmed.includes("\n") ||
      /^\\\[([\s\S]*)\\\]$/s.test(trimmed) ||
      /^\$\$([\s\S]*)\$\$$/s.test(trimmed)
    ) {
      return "block";
    }
    return "inline";
  }

  function renderMath() {
    const elements = editor.getBody().querySelectorAll("span.math-tex");
    elements.forEach((el) => {
      removeMathJaxOutput(el);
      if (window.MathJax && window.MathJax.typesetPromise) {
        window.MathJax.typesetPromise([el]).catch((err) => {
          console.error("MathJax rendering error:", err);
        });
      }
    });
  }

  // --- Clean up empty paragraphs above block math ---
  function cleanEmptyParagraphsAboveBlock() {
    const body = editor.getBody();
    const blocks = body.querySelectorAll(
      'p > span.math-tex[contenteditable="false"]'
    );
    blocks.forEach((block) => {
      const p = block.closest("p");
      if (
        p &&
        p.previousElementSibling &&
        p.previousElementSibling.tagName === "P"
      ) {
        const prev = p.previousElementSibling;
        if (
          !prev.textContent.trim() ||
          prev.innerHTML.trim() === "<br>" ||
          prev.innerHTML.trim() === "&#8203;"
        ) {
          prev.remove();
        }
      }
    });
  }

  // --- LaTeX Wrapping/Unwrapping ---
  function stripLatexWrappers(latex) {
    let trimmed = latex.trim();
    // Loại bỏ các dòng chỉ chứa \[ hoặc \] hoặc $$
    trimmed = trimmed
      .replace(/^(\\\[|\\\(|\$\$)\s*$/m, "")
      .replace(/^\s*(\\\]|\\\)|\$\$)$/m, "");
    // Loại bỏ bọc block/inline ở đầu/cuối (dù lặp nhiều lần, kể cả nhiều dòng)
    while (
      /^\\\[(.|\n)+\\\]$/.test(trimmed) ||
      /^\\\((.|\n)+\\\)$/.test(trimmed) ||
      /^\$\$(.|\n)+\$\$$/.test(trimmed)
    ) {
      trimmed = trimmed
        .replace(/^\\\[(.|\n)+\\\]$/, (m) => m.slice(2, -2).trim())
        .replace(/^\\\((.|\n)+\\\)$/, (m) => m.slice(2, -2).trim())
        .replace(/^\$\$(.|\n)+\$\$$/, (m) => m.slice(2, -2).trim());
    }
    return trimmed;
  }

  function wrapLatex(latex, mode) {
    let trimmed = stripLatexWrappers(latex);
    // Nếu đã có bọc đúng kiểu, giữ nguyên
    if (
      (mode === "block" &&
        (/^\\\[([\s\S]*)\\\]$/.test(trimmed) ||
          /^\$\$([\s\S]*)\$\$$/.test(trimmed))) ||
      (mode === "inline" && /^\\\(([\s\S]*)\\\)$/.test(trimmed))
    ) {
      return trimmed;
    }
    // Sau khi loại bỏ, bọc lại đúng kiểu
    if (mode === "block") return "\\[" + trimmed + "\\]";
    return "\\(" + trimmed + "\\)";
  }

  // --- Math Preview ---
  function renderPreview(preview, latex) {
    if (!preview) return;
    preview.className = "mathjax-preview";
    try {
      const mode = detectMathMode(latex || "");
      preview.innerHTML = wrapLatex(latex || "", mode);
      if (window.MathJax && window.MathJax.typesetPromise) {
        window.MathJax.typesetPromise([preview]).catch(function (err) {
          preview.innerHTML =
            '<span style="color:#dc2626">Invalid LaTeX: ' +
            err.message +
            "</span>";
        });
      }
    } catch (e) {
      preview.innerHTML = '<span style="color:#dc2626">Invalid LaTeX</span>';
    }
  }

  // --- Insert Math into Editor ---
  function insertMath(latex) {
    const mode = detectMathMode(latex);
    const encoded = encodeURIComponent(latex);
    const mathSpan =
      '<span class="math-tex" contenteditable="false" data-latex="' +
      encoded +
      '">' +
      wrapLatex(latex, mode) +
      "</span>";
    if (mode === "block") {
      editor.insertContent("<p>" + mathSpan + "&#8203;</p>");
      setTimeout(cleanEmptyParagraphsAboveBlock, 0);
    } else {
      editor.insertContent(mathSpan);
    }
    renderMath();
  }

  // --- Math Dialog (Insert & Edit) ---
  function openMathDialog({ title, latex, onSubmitText, onSubmit }) {
    let previewId = "mathjax-preview-" + Date.now();
    editor.windowManager.open({
      title,
      body: {
        type: "panel",
        items: [
          {
            type: "textarea",
            name: "latex",
            label: "LaTeX code",
            multiline: true,
            minHeight: 60,
            initialValue: latex,
          },
          {
            type: "htmlpanel",
            html: `<div id='${previewId}'></div>`,
          },
        ],
      },
      buttons: [
        { type: "cancel", text: "Close" },
        { type: "submit", text: onSubmitText, primary: true },
      ],
      initialData: { latex },
      onChange: function (api, details) {
        if (details.name === "latex") {
          const data = api.getData();
          const preview = document.getElementById(previewId);
          renderPreview(preview, data.latex);
        }
      },
      onSubmit: function (api) {
        const data = api.getData();
        onSubmit(data, previewId);
        api.close();
      },
      onOpen: function (api) {
        const data = api.getData();
        const preview = document.getElementById(previewId);
        renderPreview(preview, data.latex);
      },
    });
  }

  // --- Toolbar Button ---
  editor.ui.registry.addButton("mathjax", {
    text: "Math",
    onAction: function () {
      openMathDialog({
        title: "Insert Math (LaTeX)",
        latex: "",
        onSubmitText: "Insert",
        onSubmit: function (data) {
          insertMath(data.latex);
        },
      });
    },
  });

  // --- Click to Edit Math ---
  editor.on("click", function (e) {
    const target = e.target;
    if (target && target.classList && target.classList.contains("math-tex")) {
      let latex = decodeURIComponent(target.getAttribute("data-latex") || "");
      openMathDialog({
        title: "Edit Math (LaTeX)",
        latex,
        onSubmitText: "Update",
        onSubmit: function (data) {
          const mode = detectMathMode(data.latex);
          // Thay thế node cũ bằng node mới
          const newSpan = document.createElement("span");
          newSpan.className = "math-tex";
          newSpan.setAttribute("contenteditable", "false");
          newSpan.setAttribute("data-latex", encodeURIComponent(data.latex));
          newSpan.innerHTML = wrapLatex(data.latex, mode);
          if (mode === "block") {
            const p = document.createElement("p");
            p.appendChild(newSpan);
            p.innerHTML += "&#8203;";
            target.closest("p").replaceWith(p);
            setTimeout(cleanEmptyParagraphsAboveBlock, 0);
          } else {
            target.replaceWith(newSpan);
          }
          renderMath();
        },
      });
    }
  });
});
